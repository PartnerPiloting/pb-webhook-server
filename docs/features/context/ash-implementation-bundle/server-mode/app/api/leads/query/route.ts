import { NextResponse } from "next/server"; import { prisma } from "@/src/server/prisma";
type Sort = { key: string; dir: "asc" | "desc" }; type FilterState = { includeAll: string[]; includeAny: string[]; exclude: string[] };
type QueryBody = { filters?: FilterState; offset?: number; limit?: number; sort?: Sort; select?: string[]; };
const ALLOWED_SORT_KEYS = new Set(["name","company","status","stage","owner","addressCity","createdAt","updatedAt"]);
const DEFAULT_SELECT = { id:true, name:true, company:true, title:true, status:true, stage:true, owner:true, email:true, phone:true, linkedinUrl:true, addressCity:true, createdAt:true, updatedAt:true } as const;
function toSelect(select?: string[]) { if (!select || select.length === 0) return DEFAULT_SELECT as any; const obj: Record<string, boolean> = { id: true }; for (const k of select) obj[k] = true; return obj; }
function buildWhere(filters?: FilterState) { if (!filters) return {}; const where: any = {}; if (filters.includeAll?.length) where.tokens = { hasEvery: filters.includeAll }; if (filters.includeAny?.length) where.AND = [...(where.AND || []), { tokens: { hasSome: filters.includeAny } }]; if (filters.exclude?.length) where.AND = [...(where.AND || []), { NOT: { tokens: { hasSome: filters.exclude } } }]; return where; }
export async function POST(req: Request) { try { const body = (await req.json()) as QueryBody; const offset = Math.max(0, body.offset ?? 0); const limit = Math.min(500, Math.max(1, body.limit ?? 100)); const where = buildWhere(body.filters); let orderBy: any = undefined; if (body.sort && ALLOWED_SORT_KEYS.has(body.sort.key)) orderBy = { [body.sort.key]: body.sort.dir }; else orderBy = { createdAt: "desc" as const }; const select = toSelect(body.select); const [rows, total] = await Promise.all([ prisma.lead.findMany({ where, orderBy, skip: offset, take: limit, select }), prisma.lead.count({ where }) ]); return NextResponse.json({ rows, total, offset, limit }); } catch (e: any) { return NextResponse.json({ error: e?.message || "Unknown error" }, { status: 500 }); } }